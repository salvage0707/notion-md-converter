---
description: 全てのチャットで参照する必要があるドキュメントです。今までのプロジェクトに関する永続記憶に関する方針です。
globs: *
alwaysApply: false
---
# Memory Management（メモリ管理）

## 基本原則
- タスクに取り組む前に「Remembering...（記憶中...）」で始め、メモリに保存された情報を読み込む
- 知識を「memory（記憶）」として参照する
- 割り当てられたタスクが完了したら以下のデータ整理プロセスを実行する：
  1. **エンティティの整理**：
     - 新しいエンティティの作成
     - 既存エンティティの更新
     - 不要または古いエンティティの削除
  2. **関係性の整理**：
     - 新しい関係性の定義
     - 既存の関係性の更新
     - 不適切または古い関係性の削除
  3. **観察結果の整理**：
     - 新しい観察結果の追加
     - 既存の観察結果の更新
     - 古い観察結果の削除

## ナレッジグラフツールの活用方法

### エンティティ管理
#### エンティティの作成 (`create_entities`)
- プロジェクト内の重要な概念、コンポーネント、機能をエンティティとして作成
- 例：`Project`, `Component`, `Function`, `Bug`, `Feature` など
- 各エンティティには適切な観察結果（observations）を含める
- **データ整理**: 新しい概念や機能が追加されたら、適切なエンティティを作成する
- 使用例：
```javascript
{
  "entities": [
    {
      "name": "NotionMDConverter",
      "entityType": "Project",
      "observations": ["Notionからエクスポートされたマークダウンファイルを変換するツール", "Node.jsで実装"]
    }
  ]
}
```

#### エンティティの削除 (`delete_entities`)
- 不要になったエンティティを削除する際に使用
- 関連する関係性も自動的に削除される
- **データ整理**: 古くなった情報や廃止された機能に関連するエンティティを定期的に削除する
- 使用例：
```javascript
{
  "entityNames": ["旧機能名", "削除された機能"]
}
```

### 関係性管理
#### 関係性の作成 (`create_relations`)
- エンティティ間の関連性を能動態で定義
- 例：`depends on`, `implements`, `contains`, `extends` など
- **データ整理**: 新しい依存関係や機能連携が発生したら、適切な関係性を定義する
- 使用例：
```javascript
{
  "relations": [
    {
      "from": "Component A",
      "to": "Component B",
      "relationType": "depends on"
    }
  ]
}
```

#### 関係性の削除 (`delete_relations`)
- 不要または誤った関係性を削除
- **データ整理**: リファクタリングや機能変更により無効になった関係性を削除する
- 使用例：
```javascript
{
  "relations": [
    {
      "from": "Component A",
      "to": "Component B",
      "relationType": "depends on"
    }
  ]
}
```

### 観察結果管理
#### 観察結果の追加 (`add_observations`)
- 既存エンティティに新しい情報や知見を追加
- コードの変更、バグ修正、機能追加などの情報を記録
- **データ整理**: 新しい発見や変更があった場合、関連エンティティの観察結果を更新する
- 使用例：
```javascript
{
  "observations": [
    {
      "entityName": "Parser",
      "contents": ["新しいフォーマットのサポートを追加", "パフォーマンスを20%向上"]
    }
  ]
}
```

#### 観察結果の削除 (`delete_observations`)
- 古くなった情報や誤った観察結果を削除
- **データ整理**: 古い情報や誤った情報を定期的に削除して、ナレッジベースの正確性を維持する
- 使用例：
```javascript
{
  "deletions": [
    {
      "entityName": "Parser",
      "observations": ["この機能は未実装"]
    }
  ]
}
```

### 情報検索
#### グラフ全体の読み込み (`read_graph`)
- プロジェクト全体の知識ベースを確認
- タスク開始時に全体像を把握するのに有効
- **データ整理**: 定期的にグラフ全体を確認し、整理が必要な箇所を特定する

#### ノード検索 (`search_nodes`)
- キーワードに基づいて関連エンティティを検索
- エンティティ名、タイプ、観察内容に対してマッチング
- **データ整理**: 特定のトピックに関連するエンティティを検索し、一貫性のある情報整理を行う
- 使用例：
```javascript
{
  "query": "parser"
}
```

#### 特定ノードの取得 (`open_nodes`)
- 名前を指定して特定のエンティティ情報を取得
- **データ整理**: 特定のエンティティの詳細を確認し、必要に応じて情報を更新する
- 使用例：
```javascript
{
  "names": ["Parser", "Formatter"]
}
```

## 効果的なメモリ管理のベストプラクティス

### エンティティ設計
- **一貫した命名規則**: エンティティ名は明確で一貫性のある命名規則を使用する
- **適切な粒度**: 大きすぎず小さすぎないエンティティ設計を心がける
- **タイプの標準化**: エンティティタイプを標準化し、一貫して使用する

### 関係性の定義
- **明確な関係性**: 関係性は具体的かつ明確に定義する
- **双方向の考慮**: 必要に応じて双方向の関係性を定義する
- **階層構造の表現**: 「contains」や「part of」などで階層関係を表現する

### 観察結果の記録
- **簡潔さと詳細さのバランス**: 観察結果は簡潔でありながら十分な情報を含める
- **時系列の考慮**: 重要な変更には日付や順序を含める
- **コンテキストの提供**: 単なる事実だけでなく、理由や背景も記録する

### 定期的なメンテナンス
- **不要データの削除**: 古くなった情報や不要なエンティティを定期的に削除
- **関係性の更新**: プロジェクト構造の変化に合わせて関係性を更新
- **整合性の確認**: エンティティと関係性の整合性を定期的に確認

## データ整理のタイミング
- **タスク完了時**: 各タスク完了後に関連するデータを整理
- **定期的な見直し**: 週次または月次でナレッジグラフ全体を見直し
- **大きな変更後**: リファクタリングや機能追加など大きな変更後に包括的な整理を実施
- **不整合発見時**: データの不整合や古い情報を発見した時点で即時整理

## タスク別メモリ活用シナリオ

### 新機能開発時
1. 関連コンポーネントの記憶を検索
2. 依存関係を確認
3. 実装後、新機能をエンティティとして追加
4. 既存コンポーネントとの関係性を定義

### バグ修正時
1. 関連するコンポーネントの記憶を検索
2. バグの原因と修正内容を観察結果として記録
3. 影響を受けるコンポーネントの情報を更新

### リファクタリング時
1. 対象コンポーネントの依存関係を確認
2. リファクタリング内容を観察結果として記録
3. 変更された関係性を更新

### コードレビュー時
1. 関連コンポーネントの記憶を参照
2. レビュー結果を観察結果として追加
3. 設計原則や標準との整合性を確認

## メモリ活用の効果
- **コンテキスト維持**: 長期間のプロジェクトでもコンテキストを維持できる
- **知識の蓄積**: チーム全体で知識を蓄積・共有できる
- **一貫性の確保**: 設計決定や実装方針の一貫性を確保できる
- **効率的な問題解決**: 過去の決定や解決策を参照できる
- **データ品質の向上**: 定期的な整理により、ナレッジベースの品質と信頼性が向上する 